name: Auto-Fix M3U Streams

on:
  workflow_dispatch:
  schedule:
    - cron: '0 */6 * * *'  # Runs every 6 hours

permissions:
  contents: write

jobs:
  auto-fix-streams:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests m3u8

      - name: Auto-Fix Streams
        run: |
          python - <<EOF
          import requests
          import os
          import re
          import time
          from datetime import datetime

          def check_stream(url, timeout=10):
              """Check if a stream URL is accessible"""
              try:
                  headers = {
                      'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                      'Accept': '*/*',
                      'Accept-Language': 'en-US,en;q=0.9',
                      'Connection': 'keep-alive',
                      'Referer': 'https://github.com/'
                  }
                  
                  # Try HEAD request first (faster)
                  try:
                      response = requests.head(url, timeout=timeout, headers=headers, allow_redirects=True)
                      if response.status_code < 400:
                          return True
                  except:
                      pass
                  
                  # If HEAD fails, try GET
                  response = requests.get(url, timeout=timeout, headers=headers, stream=True, allow_redirects=True)
                  return response.status_code < 400
                  
              except Exception as e:
                  return False

          def is_event_channel(channel_name):
              """Check if a channel is event-based and expected to be offline"""
              try:
                  channel_name = channel_name.strip().upper()
                  
                  # Check for PPV channels (PPV1, PPV2, PPV, etc.)
                  if channel_name.startswith('PPV'):
                      return True
                  
                  # Check for numbered sports channels (NBA 1, NFL 2, etc.)
                  event_keywords = ['NBA ', 'NFL ', 'NHL ', 'MLB ']
                  for keyword in event_keywords:
                      if channel_name.startswith(keyword):
                          try:
                              # Check if there's a number after the keyword
                              parts = channel_name.split()
                              if len(parts) >= 2 and parts[1].isdigit():
                                  return True
                          except:
                              continue
                  
                  return False
              except:
                  return False

          def find_fl_variations(url):
              """Generate different fl variations to test"""
              variations = []
              fl_pattern = r'fl(\d+)'
              match = re.search(fl_pattern, url)
              
              if match:
                  # Test range fl1 to fl61
                  for num in range(1, 62):
                      new_url = re.sub(fl_pattern, f'fl{num}', url)
                      variations.append(new_url)
              
              return variations

          def parse_m3u(file_path):
              """Parse M3U file and return streams with their line numbers"""
              if not os.path.exists(file_path):
                  print(f"File not found: {file_path}")
                  return [], []
                  
              try:
                  with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                      lines = f.readlines()
              except Exception as e:
                  print(f"Error reading {file_path}: {str(e)}")
                  return [], []
              
              streams = []
              
              for i in range(len(lines)):
                  line = lines[i].strip()
                  if line.startswith('#EXTINF'):
                      try:
                          # Extract channel name
                          name_part = line.split(',')[-1].strip()
                          name = name_part if name_part else "Unknown Channel"
                          
                          # Get URL from next line
                          if i + 1 < len(lines):
                              url = lines[i + 1].strip()
                              if url and not url.startswith('#') and 'http' in url:
                                  streams.append({
                                      'name': name,
                                      'url': url,
                                      'extinf_line': i,
                                      'url_line': i + 1
                                  })
                      except Exception as e:
                          print(f"Error parsing line {i}: {str(e)}")
                          continue
              
              return streams, lines

          def update_m3u_file(file_path, lines, url_line, new_url):
              """Update M3U file with new URL"""
              try:
                  lines[url_line] = new_url + '\n'
                  with open(file_path, 'w', encoding='utf-8') as f:
                      f.writelines(lines)
              except Exception as e:
                  print(f"Error updating file: {str(e)}")

          # Your M3U files
          m3u_files = [
              'moj.m3u'
          ]

          # Initialize tracking variables
          total_streams = 0
          total_fixed = 0
          failed_streams = []
          fixed_streams = []
          checked_streams = 0
          event_channels_updated = 0
          working_fl_number = None  # Track what fl number is currently working

          print("Starting auto-fix process...")

          try:
              for m3u_file in m3u_files:
                  if not os.path.exists(m3u_file):
                      print(f"File not found: {m3u_file}")
                      continue
                      
                  print(f"\nProcessing {m3u_file}...")
                  
                  streams, original_lines = parse_m3u(m3u_file)
                  file_fixed = 0
                  total_streams = len(streams)
                  
                  print(f"Found {len(streams)} streams")
                  
                  # First pass: find a working fl number by testing a few regular channels
                  if working_fl_number is None:
                      print("\nðŸ” Finding which 'fl' number is currently working...")
                      test_count = 0
                      
                      for stream in streams:
                          if test_count >= 10:  # Limit testing to first 10 streams
                              break
                              
                          # Skip event channels for initial testing
                          if is_event_channel(stream['name']):
                              continue
                              
                          if 'fl' in stream['url'] and re.search(r'fl\d+', stream['url']):
                              test_count += 1
                              print(f"Testing {stream['name']} to find working fl number...")
                              
                              if check_stream(stream['url']):
                                  current_fl = re.search(r'fl(\d+)', stream['url']).group(1)
                                  working_fl_number = current_fl
                                  print(f"âœ… Found working fl number: fl{working_fl_number}")
                                  break
                              else:
                                  # Try to find what fl number works for this stream
                                  variations = find_fl_variations(stream['url'])
                                  for variation in variations[:20]:  # Test first 20 variations
                                      if check_stream(variation):
                                          working_fl_number = re.search(r'fl(\d+)', variation).group(1)
                                          print(f"âœ… Found working fl number: fl{working_fl_number}")
                                          break
                                  if working_fl_number:
                                      break
                      
                      if not working_fl_number:
                          print("âŒ Could not determine working fl number, will test each stream individually")
                  
                  # Second pass: fix all streams using the working fl number
                  print(f"\nðŸ”§ Now checking and fixing all streams...")
                  
                  current_lines = original_lines.copy()  # Work with a copy to avoid re-parsing
                  
                  for stream in streams:
                      checked_streams += 1
                      print(f"Checking ({checked_streams}/{total_streams}): {stream['name'][:50]}...")
                      
                      is_event = is_event_channel(stream['name'])
                      
                      if is_event:
                          print(f"  ðŸ“º Event channel - updating fl number without testing connectivity")
                          # For event channels, just update fl number if we have a working one and it's different
                          if working_fl_number and 'fl' in stream['url'] and re.search(r'fl\d+', stream['url']):
                              current_fl = re.search(r'fl(\d+)', stream['url']).group(1)
                              
                              if current_fl != working_fl_number:
                                  new_url = re.sub(r'fl\d+', f'fl{working_fl_number}', stream['url'])
                                  print(f"    ðŸ“ Updating fl number from fl{current_fl} to fl{working_fl_number}")
                                  
                                  # Update the working copy of lines
                                  update_m3u_file(m3u_file, current_lines, stream['url_line'], new_url)
                                  
                                  fixed_streams.append({
                                      'name': stream['name'],
                                      'file': m3u_file,
                                      'original_url': stream['url'],
                                      'new_url': new_url,
                                      'old_fl': current_fl,
                                      'new_fl': working_fl_number,
                                      'is_event_channel': True
                                  })
                                  
                                  total_fixed += 1
                                  file_fixed += 1
                                  event_channels_updated += 1
                                  
                                  # Update the stream URL in our working copy for consistency
                                  stream['url'] = new_url
                                  current_lines[stream['url_line']] = new_url + '\n'
                              else:
                                  print(f"    âœ… Already using current working fl{working_fl_number}")
                          else:
                              print(f"    â„¹ï¸  Waiting for working fl number to be determined")
                          continue
                      
                      # Regular channel - test connectivity
                      print(f"  ðŸ” Testing regular channel connectivity...")
                      if check_stream(stream['url']):
                          print(f"  âœ… Working - no changes needed")
                          continue
                      
                      print(f"  âŒ Regular channel failed - needs fixing")
                      
                      # Look for fl pattern and try to fix
                      if 'fl' in stream['url'] and re.search(r'fl\d+', stream['url']):
                          current_fl = re.search(r'fl(\d+)', stream['url']).group(1)
                          
                          if working_fl_number:
                              # Try the known working fl number first
                              if current_fl != working_fl_number:
                                  new_url = re.sub(r'fl\d+', f'fl{working_fl_number}', stream['url'])
                                  print(f"    Testing known working fl{working_fl_number}...")
                                  
                                  if check_stream(new_url):
                                      print(f"    âœ… fl{working_fl_number} works! Updating...")
                                      
                                      # Update the file
                                      update_m3u_file(m3u_file, current_lines, stream['url_line'], new_url)
                                      
                                      fixed_streams.append({
                                          'name': stream['name'],
                                          'file': m3u_file,
                                          'original_url': stream['url'],
                                          'new_url': new_url,
                                          'old_fl': current_fl,
                                          'new_fl': working_fl_number,
                                          'is_event_channel': False
                                      })
                                      
                                      total_fixed += 1
                                      file_fixed += 1
                                      
                                      # Update working copy
                                      stream['url'] = new_url
                                      current_lines[stream['url_line']] = new_url + '\n'
                                      continue
                              else:
                                  # Known working fl number doesn't work for this channel, test others
                                  print(f"    âŒ Known fl{working_fl_number} doesn't work for this channel")
                          
                          # Test other variations
                          print(f"    ðŸ” Testing other fl variations...")
                          variations = find_fl_variations(stream['url'])
                          found_working = False
                          
                          for i, variation in enumerate(variations):
                              # Skip the current fl number (we know it doesn't work)
                              variation_fl = re.search(r'fl(\d+)', variation).group(1)
                              if variation_fl == current_fl:
                                  continue
                              
                              # Skip the known working fl if we already tested it
                              if working_fl_number and variation_fl == working_fl_number:
                                  continue
                              
                              print(f"    Testing fl{variation_fl}...")
                              
                              if check_stream(variation):
                                  print(f"    âœ… fl{variation_fl} works! Updating...")
                                  
                                  # Update working fl number for future use
                                  working_fl_number = variation_fl
                                  
                                  # Update the file
                                  update_m3u_file(m3u_file, current_lines, stream['url_line'], variation)
                                  
                                  fixed_streams.append({
                                      'name': stream['name'],
                                      'file': m3u_file,
                                      'original_url': stream['url'],
                                      'new_url': variation,
                                      'old_fl': current_fl,
                                      'new_fl': variation_fl,
                                      'is_event_channel': False
                                  })
                                  
                                  total_fixed += 1
                                  file_fixed += 1
                                  found_working = True
                                  
                                  # Update working copy
                                  stream['url'] = variation
                                  current_lines[stream['url_line']] = variation + '\n'
                                  break
                              
                              time.sleep(0.1)  # Small delay between tests
                          
                          if not found_working:
                              print(f"    âŒ No working alternatives found")
                              failed_streams.append({
                                  'name': stream['name'],
                                  'file': m3u_file,
                                  'url': stream['url']
                              })
                      else:
                          print(f"    âš ï¸  No 'fl' pattern found in URL")
                          failed_streams.append({
                              'name': stream['name'],
                              'file': m3u_file,
                              'url': stream['url']
                          })
                      
                      time.sleep(0.1)  # Short delay between streams
                  
                  print(f"\nFile {m3u_file}: Fixed {file_fixed} streams")
                  if working_fl_number:
                      print(f"Current working fl number: fl{working_fl_number}")

          except Exception as e:
              print(f"Error in main processing: {str(e)}")

          # Generate report
          try:
              regular_channels = len([s for s in streams if not is_event_channel(s['name'])])
              event_channels = total_streams - regular_channels
              
              success_rate = ((total_streams - len(failed_streams)) / total_streams * 100) if total_streams > 0 else 100
              
              report = f"""# ðŸ”§ M3U Stream Status Report
              
              **Last Updated:** {datetime.utcnow().strftime('%B %d, %Y at %H:%M UTC')}
              
              ## ðŸ“Š Quick Summary
              
              **Overall Health:** {success_rate:.1f}% of streams are working  
              **Current FL Server:** fl{working_fl_number if working_fl_number else 'Unknown'}  
              **Changes Made:** {total_fixed} streams updated  
              **Issues Found:** {len(failed_streams)} streams need attention  
              
              ---
              
              ## ðŸ“ˆ Detailed Breakdown
              
              | Category | Working | Fixed | Failed | Total |
              |----------|---------|-------|--------|-------|
              | Regular Channels | {regular_channels - len([s for s in failed_streams if not is_event_channel(s['name'])])} | {len([s for s in fixed_streams if not s.get('is_event_channel', False)])} | {len([s for s in failed_streams if not is_event_channel(s['name'])])} | {regular_channels} |
              | Event Channels | N/A | {len([s for s in fixed_streams if s.get('is_event_channel', False)])} | 0 | {event_channels} |
              | **TOTAL** | **{total_streams - len(failed_streams)}** | **{total_fixed}** | **{len(failed_streams)}** | **{total_streams}** |
              
              """
              
              if fixed_streams:
                  # Separate regular channels from event channels
                  regular_fixes = [s for s in fixed_streams if not s.get('is_event_channel', False)]
                  event_fixes = [s for s in fixed_streams if s.get('is_event_channel', False)]
                  
                  if regular_fixes:
                      report += f"""## âœ… Successfully Fixed ({len(regular_fixes)} channels)
              
              These channels were broken but are now working:
              
              """
                      # Group by FL change for cleaner display
                      fl_groups = {}
                      for stream in regular_fixes:
                          fl_change = f"fl{stream['old_fl']} â†’ fl{stream['new_fl']}"
                          if fl_change not in fl_groups:
                              fl_groups[fl_change] = []
                          fl_groups[fl_change].append(stream['name'])
                      
                      for fl_change, channels in fl_groups.items():
                          report += f"**{fl_change}:** {', '.join(channels)}  \n"
                      
                  if event_fixes:
                      report += f"""
              ## ðŸ”„ Event Channels Updated ({len(event_fixes)} channels)
              
              These event channels were updated to stay current (they're expected to be offline unless there's a live event):
              
              """
                      # Group event fixes too
                      event_fl_groups = {}
                      for stream in event_fixes:
                          fl_change = f"fl{stream['old_fl']} â†’ fl{stream['new_fl']}"
                          if fl_change not in event_fl_groups:
                              event_fl_groups[fl_change] = []
                          event_fl_groups[fl_change].append(stream['name'])
                      
                      for fl_change, channels in event_fl_groups.items():
                          report += f"**{fl_change}:** {', '.join(channels)}  \n"
              
              if failed_streams:
                  regular_failed = [s for s in failed_streams if not is_event_channel(s['name'])]
                  
                  if regular_failed:
                      report += f"""
              ## âŒ Channels Still Having Issues ({len(regular_failed)} channels)
              
              These channels couldn't be fixed and may need manual attention:
              
              """
                      for stream in regular_failed:
                          report += f"â€¢ **{stream['name']}** - {stream.get('issue', 'No working fl server found')}  \n"
                      
                      report += f"""
              > ðŸ’¡ **Tip:** These channels might be temporarily down, using different servers, or may need different fixes.
              """
              
              if total_fixed > 0:
                  report += f"""
              ## ðŸŽ‰ Success!
              
              **{total_fixed} streams were automatically updated** and should now be working properly. The playlist has been saved with the new URLs.
              """
              else:
                  report += f"""
              ## ðŸ‘ All Good!
              
              No updates were needed - your streams are already current and working well.
              """
              
              report += f"""
              
              ---
              
              ## ðŸ”§ Technical Details
              
              **Process:** Automatically tested fl1 through fl61 to find working servers  
              **Detection:** Smart system finds working FL number first, then applies it efficiently  
              **Safety:** Event channels (PPV, NBA, NFL, etc.) updated without connectivity testing  
              **Next Check:** This will run again automatically in 6 hours  
              
              *Generated by GitHub Actions â€¢ Report v2.0*
              """
              
              # Write report
              with open('auto-fix-report.md', 'w', encoding='utf-8') as f:
                  f.write(report)
              
              print(f"\nðŸŽ¯ Final Summary:")
              print(f"   Total streams: {total_streams}")
              print(f"   Regular channels: {regular_channels}")
              print(f"   Event channels: {event_channels}")
              print(f"   Fixed/Updated: {total_fixed}")
              print(f"   Still failing: {len(failed_streams)}")
              
              if total_fixed > 0:
                  print(f"\nâœ… Successfully updated {total_fixed} streams!")
                  
          except Exception as e:
              print(f"Error generating report: {str(e)}")
          EOF

      - name: Commit and push changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "github-actions[bot]"
          git add .
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "ðŸ”§ Auto-fix M3U streams - $(date -u '+%Y-%m-%d %H:%M UTC')"
            git push
          fi
